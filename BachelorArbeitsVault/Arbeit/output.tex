\hypertarget{experiment}{%
\section{3. Experiment}\label{experiment}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{eingebettetes-system-zur-messung-der-raddaten}{%
\subsection{Eingebettetes System zur Messung der
Raddaten}\label{eingebettetes-system-zur-messung-der-raddaten}}

Damit der Software bekannt ist, mit welcher Geschwindigkeit sich welches
Rad in welche Richtung dreht, ist Hardware notwendig, welche die
Rotationsdaten misst und an die Software übermittelt. Dazu wurde für das
vorliegende Experiment ein eingebettetes System verwendet. Im Folgenden
soll näher beleuchtet und erörtert werden, welche Hardware verwendet und
wie die Raddaten gemessen und übertragen wurden. Dazu werden im
Folgenden verschiedene Kommunikationsprotokolle verglichen.

\hypertarget{gyroskop}{%
\subsubsection{Gyroskop}\label{gyroskop}}

Um die Rotation der Räder des Rollstuhls messen zu können, wird ein
Sensor benötigt. Dabei gibt es verschiedene Herangehensweisen, wie ein
Sensor die Rotation messen kann. So arbeiten viele Sensoren mit
Lichtschranken. Hierbei wird die Lichtschranke in regelmäßigen Abständen
durch ein Hindernis blockiert. Daraus kann dann über die Frequenz, in
der dies geschieht, eine Geschwindigkeit errechnet werden. Vorteil ist
dabei, dass keine Hardware auf dem Rad befestigt werden muss und deshalb
kein mobiles System benötigt wird. Es kann auf Technologien wie WiFi und
Akkus verzichtet werden. Ein großer Nachteil bei diesem Verfahren ist
jedoch XYZ, dass für besonders kleine Rotationen die Abstände der
Hindernisse sehr klein sein müssen. Angewandt auf den Rollstuhl bedeutet
dies, dass eine zusätzliche Konstruktion gebaut werden muss, damit die
Lichtschranke unterbrochen wird. Da dies sehr unpraktikabel ist, wurde
dieses Verfahren nicht verwendet. Die zweite Möglichkeit ist die
Verwendung eines Gyroskops. Dieses kommt ohne zusätzliche Konstruktionen
aus, erfordert jedoch, dass die Elektronik mobil ist. Die Datenrate wird
folglich durch die Bandbreite des drahtlosen Netzwerks begrenzt, da die
Übertragung von Daten den Flaschenhals solcher Systeme darstellt.

\hypertarget{mpu-6050}{%
\subsubsection{MPU-6050}\label{mpu-6050}}

Im Zuge dieser Arbeit habe ich mich für den MPU-6050 entschieden. Dieser
ist klein (mit Pins: 20mm x 15mm x 11mm), kostengünstig zu erwerben
(\textasciitilde4€) und verfügt unter anderem über 3-Achsen
Gyroskop-Sensoren, mit welchen die Rotation gemessen werden kann. Der
Chip besitzt folgende 8 Anschlüsse:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1268}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3099}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.5634}}@{}}
\toprule()
\begin{minipage}[b]{\linewidth}\raggedright
Anschluss
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Funktion
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Notwendig für das vorliegende Experiment
\end{minipage} \\
\midrule()
\endhead
VCC & Power-Supply & Ja \\
GND & Ground & Ja \\
SCL & Serial-Clock & Ja \\
SDA & Serial-Daten & Ja \\
XDA & Auxiliary Serial Data & Nein \\
XCL & Auxiliary Serial Clock & Nein \\
ADO & I2C Address Select & Ja \\
INT & Interrupt & Nein \\
\bottomrule()
\end{longtable}

Die Daten können per I2C von einem angeschlossenen Mikrocontroller
ausgelesen werden. Jede Achse wird auf zwei 8-Bit Register abgebildet.
Zusammen ergibt das einen Wertebereich von 65.536 unterscheidbaren
Zuständen. Mit der Drehrichtung halbiert sich dieser Wertebereich, da
ein Bit für das Verschieben des Wertebereichs ins Negative benötigt
wird. Das Gyroskop des MPU-6050 kann in vier verschiedenen
Konfigurationen betrieben werden. Damit wird festgelegt, wie klein der
Winkel zwischen zwei verschiedenen Ausgaben ist; mit anderen Worten: wie
viele Stufen pro Grad unterschieden werden können. Da der Wertebereich
konstant ist, bedeutet eine sensiblere Messung, dass das Gyroskop früher
das Ende des Wertebereichs erreicht. Angewendet auf den Rollstuhl heißt
das, dass das rotierende Rad bei niedrigeren Geschwindigkeiten seine
maximal messbare Geschwindigkeit erreicht. In der folgenden Tabelle sind
alle Konfigurationen mit ihren resultierenden Eigenschaften aufgelistet.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.0329}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1908}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.0987}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.2303}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.1974}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 10\tabcolsep) * \real{0.2500}}@{}}
\toprule()
\begin{minipage}[b]{\linewidth}\raggedright
Modus
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Maximale Gradzahl pro Sekunde
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Stufen pro Grad
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Maximale Umdrehungszahl pro Sekunde
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Maximale Radianten pro Sekunde
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Zurückgelegte Distanz pro Stufe in mm*
\end{minipage} \\
\midrule()
\endhead
0 & 250 & 131 & 0,69 & 4,36 & 0,04 \\
1 & 500 & 65,5 & 1,39 & 8,73 & 0,08 \\
2 & 1000 & 32,8 & 2,78 & 17,47 & 0,16 \\
3 & 2000 & 16,4 & 5,56 & 34,93 & 0,32 \\
\bottomrule()
\end{longtable}

*Werte bei einem Raddurchmesser von 60 cm.

welcher wert sollte gewählt werden und warum?

\hypertarget{esp32}{%
\subsubsection{ESP32}\label{esp32}}

Um den MPU-6050 betreiben und dessen Daten an eine Software übermitteln
zu können, wird ein Mikrocontroller-Board benötigt. Es muss per I2C die
entsprechenden Register auslesen und mittels drahtloser Kommunikation
versenden. Außerdem muss er das Gyroskop, sowie sich selbst mit Strom
versorgen. Auf dem Markt gibt es eine große Anzahl von Produkten, für
die verschiedensten Anwendungsgebiete und mit den verschiedensten
Features. Im Rahmen dieser Arbeit wurde der Mikrocontroller ESP32
verwendet, das aktuellste Modell der Firma \emph{Espressif}. Boards mit
diesem Chip sind kostengünstig (\textasciitilde8€) und ermöglichen ein
unkompliziertes Arbeiten mit der Hardware, da der Chip verbreitet ist
und viel Literatur und Anleitungen existieren. Ausgestattet ist der
ESP32 mit WiFi und Bluetooth Unterstützung, Espressif bietet aber auch
ein eigenes Verbindungsprotokoll an: \emph{ESP-Now}. Verbaut wurde ein
Xtensa® 32-bit LX6 Mikroprozessor, mit 240MHz Taktfrequenz, 448 KB ROM
und 520 KB SRAM. {[}\citep{ESP32Datasheet2022}{]} Als Entwicklungsboard
wurde das ESP32 Dev Kit C V4 verwendet.

Der MPU-6050 muss wie folgt an das Entwicklungsboard angeschlossen
werden:

\begin{longtable}[]{@{}ll@{}}
\toprule()
ESP32 & MPU-6050 \\
\midrule()
\endhead
3.3V & VCC \\
GND & GND \\
GPIO\_22 (I2C CL) & SDA \\
GPIO\_21 (I2C DA) & SCL \\
ADO & GND \\
\bottomrule()
\end{longtable}

\hypertarget{platformio}{%
\subsubsection{PlatformIO}\label{platformio}}

Zur Entwicklung der Software, die auf den Mikrocontrollern läuft, wurde
PlatformIO verwendet. Dies ist eine Erweiterung für Visual Studio Code,
bei der die benötigten Bibliotheken, die für jeden Mikrocontroller und
jedes Board notwendig sind, automatisch heruntergeladen und eingerichtet
werden. Ebenfalls lassen sich über das UI Bibliotheken, die für das
jeweilige Projekt notwendig sind, hinzufügen. Zusätzlich zur
Entwicklungsumgebung von Visual Studio Code gibt es Funktionalitäten
einen Chip zu flashen und anschließend im seriellen Monitor die
Ausführung zu beobachten. Im Gegensatz zu Umgebungen wie der Arduino IDE
wird Zeit gespart, da dort zunächst manuell Treiber heruntergeladen
werden müssen und man nicht von den Vorteilen einer moderneren IDE
profitiert.

\hypertarget{d-gedruckte-box}{%
\subsubsection{3D gedruckte Box}\label{d-gedruckte-box}}

Damit Entwicklungsboard, Gyroskop und Akku zusammengehalten werden,
geschützt sind und am Rad befestigt werden können, wird eine Box
benötigt, die alle Komponenten aufnehmen kann und diese trägt. Aufgrund
dessen habe ich für meine Arbeit - mithilfe von Blender - eine
entsprechend seinen Anforderungen konstruierte Box entworfen, welche ich
mithilfe eines 3D-Druckers drucken ließ.

\hypertarget{transfer-der-gyroskop-daten}{%
\subsection{Transfer der
Gyroskop-Daten}\label{transfer-der-gyroskop-daten}}

Für die Übermittlung der Sensordaten an eine Software auf einem PC
stehen verschiedene Möglichkeiten zur Verfügung. In dieser Arbeit sind
zwei verschiedene Protokolle getestet worden: WiFi und ESP-Now. Die
Protokolle müssen dabei leicht in das System integrierbar sein. WiFi ist
ein weit verbreiteter Standard, sodass entsprechende Bibliotheken schon
existieren, um das Protokoll einfach einbinden zu können. ESP-Now ist
weniger verbreitet, da aber der Chip vom selben Hersteller kommt,
existieren auch hier schon Bibliotheken. Ein weiteres Protokoll, welches
ebenfalls hätte getestet werden können ist Bluetooth, das jedoch
aufgrund des zeitlichen Rahmens dieser Arbeit nicht getestet werden
konnte.

\hypertarget{wifi-und-websockets}{%
\subsubsection{WiFi und WebSockets}\label{wifi-und-websockets}}

\begin{quote}
TODO warum nicht udp? warum tcp? alternativen? TODO
\end{quote}

WiFi ist eine Kommunikations-Technologie, die durch die WiFi-Allianz
entstanden ist und bis heute von ihr gepflegt wird. Sie ermöglicht
drahtlose Kommunikation mit jedem Gerät, das diese Technologie
implementiert. Inzwischen ist WiFi ein weit verbreiteter Standard,
welches von den meisten mobilen Geräten unterstützt wird. Der ESP32
verwendet das WiFi Protokoll 802.11 und arbeitet im 2,4-2,5 GHz Bereich.
Quelle Zunächst muss eine Verbindung zwischen dem ESP32 und dem lokalen
Netzwerk mittels WiFi aufgebaut werden. Damit die Zugangsdaten nicht
fest in den Code geschrieben werden müssen, wird die Bibliothek
\emph{WiFi Manager} verwendet. Die Bibliothek baut selbstständig eine
Verbindung mit einem Netzwerk auf, nachdem die Zugangsdaten über ein
Gerät wie zum Beispiel einem Smartphone übergeben wurden. Dazu wird ein
Web-Konfigurations-Portal auf dem ESP32 gehostet, auf das ein nahes
Gerät zugreifen kann. {[}\citep{tzapuWiFiManager2022}{]}

Für die eigentliche Übertragung der Daten können verschiedene Protokolle
verwendet werden. Ein klassischer Vertreter ist HTTP(S). Jedoch ist das
Protokoll auf Hypertext ausgelegt. Es wird für jede Abfrage von Daten
eine neue TCP-Verbindung mit dem Server aufgebaut, der die Daten nach
Eingang der Anfrage zurückschickt. Will der Client auf dem Rechner neue
Daten empfangen, so muss dieser erneut eine Verbindung aufbauen und eine
neue Anfrage an den Server stellen. Zusätzlich ist in jedem Paket viel
Overhead. Bei HTTP werden in der Praxis verschiedene Header und
Cookie-Daten mitgesendet, die zusammen ein paar Kilobyte groß sind. Im
Szenario dieser Arbeit würde der ESP32 einen Server hosten. Eine
Software auf einem externen Rechner würde bei diesem Server neue Daten
abfragen. Da es sich bei diesem System jedoch um Echtzeitdaten handelt,
wäre dieses Vorgehen ineffizient, da viel Zeit für das Übertragen von
nicht benötigte Daten verwendet werden würde.

Eine Alternative ist die Verwendung eines WebSockets. Es wurde
entwickelt, um das oben geschilderte Problem zu lösen und wird heute
breit unterstützt. Das Web-Socket-Protokoll wurde in seiner finalen Form
2011 von der Internet Engineering Task Force entwickelt und
veröffentlicht. {[}\citep{ietfRFC6455WebSocket}{]} Dabei wird analog zu
HTTP am Anfang ein TCP Handshake durchgeführt. Der Clienten stellt an
den Server eine Verbindungsanfrage, den der Server bestätigt. Ab diesem
Zeitpunkt sendet der Server unaufgefordert die vom Clienten abonnierten
Daten, bis die Verbindung vom Clienten beendet wird. Somit lassen sich
höhere Datenraten erzielen, die für Echtzeitanwendungen notwendig sind.
Das für die vorliegende Bachelor-Thesis entwickelte System setzt auf
einen vom ESP32 gehosteten WebSocket-Server, der von einer Software auf
dem PC abonniert wird und die Daten weiter verarbeitet.

Zusätzlich zur eigentlichen Übertragung der Daten ist es notwendig, dass
die Software auf dem PC den IP-Endpunkt des WebSockets auf dem ESP32
kennt. Dazu sendet der Mikrocontroller ebenfalls über WiFi einen
UDP-Broadcast ins Netzwerk. Neben dem IP-Endpunkt, werden auch
Informationen über das Gerät mitgesendet, damit die Software auf dem PC
weiß, um welches Gerät es sich handelt. Nach dieser Bekanntmachung kann
der WebSocket abonniert und die Daten übertragen werden.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4848}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5152}}@{}}
\toprule()
\begin{minipage}[b]{\linewidth}\raggedright
Vorteile
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Nachteile
\end{minipage} \\
\midrule()
\endhead
Direkte Kommunikation der Geräte zur PC-Software & Verbindungsaufbau ist
aufwändiger zu implementieren \\
Nur zwei Geräte werden benötigt & \\
Zugangsdaten müssen nicht fest-gecodet werden & \\
\bottomrule()
\end{longtable}

\hypertarget{esp-now-und-serieller-port}{%
\subsubsection{ESP-Now und Serieller
Port}\label{esp-now-und-serieller-port}}

ESP-Now ist ein vom Unternehmen \emph{Espressif} selbst entwickeltes
Übertragungsprotokoll, mit dem Mikrocontroller von \emph{Espressif} wie
zum Beispiel der ESP8266 (Vorgänger des ESP32) und der ESP32 direkt
miteinander Daten austauschen können. Dabei verwendet das Protokoll die
MAC-Adressen zur Identifikation der Geräte. Es wird jedoch nur eine
Verbindung in eine Richtung aufgebaut. Ein großer Vorteil dieses
Protokolls ist die einfache Einbindung in das System. Anders als WiFi
muss nicht zunächst eine Verbindung zu einem Netzwerk aufgebaut werden,
sondern dem Gerät muss lediglich die MAC-Adresse des Zielgeräts
vorliegen. Da die Kommunikation jedoch nur unter Mikrocontrollern
stattfindet, muss das Gerät, welches die Sensor-Daten entgegennimmt,
diese Daten mittels seriellen Ports an die Software auf dem PC
übertragen. Damit steigt die Anzahl der Verbindungen, an denen die
Übertragung scheitern kann. Jedoch erleichtert es die Verwendung für den
Endbenutzer, da dieser kein WiFi-Netzwerk benötigt, um die Geräte mit
der Software auf dem PC zu verbinden. Eine Verbindung per USB-Kabel ist
ausreichend.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4121}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5879}}@{}}
\toprule()
\begin{minipage}[b]{\linewidth}\raggedright
Vorteile
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Nachteile
\end{minipage} \\
\midrule()
\endhead
Kein WiFi oder Bluetooth notwendig & Zwei statt einer Verbindung muss
aufrecht erhalten werden \\
Das empfangende Gerät kann einfach mit einem USB-Kabel angeschlossen
werden & Ein zusätzliches Gerät wird benötigt, um die Daten zu empfangen
und an die Software weiterzureichen \\
& Die Ziel-MAC-Adressen müssen im Code hartkodiert werden oder über
andere Wege übertragen werden \\
\bottomrule()
\end{longtable}

\hypertarget{bluetooth}{%
\subsubsection{Bluetooth}\label{bluetooth}}

\hypertarget{messungen}{%
\subsubsection{Messungen}\label{messungen}}

\begin{itemize}
\tightlist
\item
  Maximale Umdrehungszahl pro Sekunde ermitteln =\textgreater{} Diagramm
\item
  verschiedene Bewegungen plotten

  \begin{itemize}
  \tightlist
  \item
    Knopf drücken im Vergleich zu Bewegung
  \item
    Neigen und bewegen (Threshold oder filter?)
  \end{itemize}
\item
  Kommunikation vergleichen
\end{itemize}

\hypertarget{alte-nodes}{%
\paragraph{Alte Nodes}\label{alte-nodes}}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
Pakete pro Sekunde & Durchschnitt & Minimum & Maximum & Delay \\
\midrule()
\endhead
Ein Node & & & & \\
Zwei Nodes & & & & \\
\bottomrule()
\end{longtable}

\hypertarget{wifi-mit-websocket}{%
\paragraph{WiFi mit WebSocket}\label{wifi-mit-websocket}}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
Pakete pro Sekunde & Durchschnitt & Minimum & Maximum & Delay \\
\midrule()
\endhead
Ein Node & ?80? & & & \\
Zwei Nodes & & & & \\
\bottomrule()
\end{longtable}

\href{https://github.com/Links2004/arduinoWebSockets/issues/21}{Messung
andere Entwickler}

\hypertarget{esp-now-mit-seriellem-port}{%
\paragraph{ESP-Now mit seriellem
Port}\label{esp-now-mit-seriellem-port}}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
Pakete pro Sekunde & Durchschnitt & Minimum & Maximum & Delay \\
\midrule()
\endhead
Ein Node & & & & \\
Zwei Nodes & & & & \\
\bottomrule()
\end{longtable}

\hypertarget{bluetooth-1}{%
\paragraph{Bluetooth}\label{bluetooth-1}}

\begin{longtable}[]{@{}lllll@{}}
\toprule()
Pakete pro Sekunde & Durchschnitt & Minimum & Maximum & Delay \\
\midrule()
\endhead
Ein Node & & & & \\
Zwei Nodes & & & & \\
\bottomrule()
\end{longtable}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{algorithmen-zur-abbildung-der-raddaten-in-eingaben}{%
\subsection{Algorithmen zur Abbildung der Raddaten in
Eingaben}\label{algorithmen-zur-abbildung-der-raddaten-in-eingaben}}

Die Sensor-Daten der Gyroskope liefern die Winkelgeschwindigkeiten der
Räder des Rollstuhls. Es sollen verschiedene Abbildungen auf Eingaben
getestet werden, um sich im virtuellen Raum bewegen zu können oder
andere Eingaben tätigen zu können. Die Abbildung erfolgt dabei auf einem
emulierten Spielcontroller. So können die Eingaben von jeder Software
entgegengenommen werden, die eine Controllerunterützung hat.

\hypertarget{abbildung-auf-einen-cursor}{%
\subsubsection{Abbildung auf einen
Cursor}\label{abbildung-auf-einen-cursor}}

Die einfachste Art und Weise, wie die Raddaten in Eingaben abgebildet
werden können, ist die Steuerung eines Cursors. Dabei wird ein Rad
genutzt, um die x-Achse abzubilden und das andere Rad bildet die y-Achse
ab. Vorteil dabei ist, dass beide Achsen gleichzeitig angesprochen
werden können. Jedoch ist es schwieriger, die x-Achse zu bewegen, da
diese anders ausgerichtet ist als das Rad, das gedreht wird.

Eine Alternative ist, dass jede Achse von beiden Rädern gesteuert wird.
Die x-Achse wird dabei dann angesprochen, wenn sich die Räder
gegeneinander drehen. Drehen sich die Räder miteinander, so wird die
y-Achse angesprochen. Jedoch ist es dabei nicht mehr möglich,
gleichzeitig den Cursor entlang beider Achsen zu bewegen, da sich die
Räder nicht gleichzeitig mit und gegeneinander drehen können.

\hypertarget{abbildung-auf-einen-realistisch-simulierten-rollstuhl}{%
\subsubsection{Abbildung auf einen realistisch simulierten
Rollstuhl}\label{abbildung-auf-einen-realistisch-simulierten-rollstuhl}}

Da das im Rahmen dieser Arbeit entwickelte System darauf abzielt im
virtuellen Raum zu navigieren, wird eine Abbildung benötigt, die die
Position des Nutzers im virtuellen Raum verändert. Die naheliegendste
Methode ist dabei die Abbildung auf einen simulierten Rollstuhl, da die
Daten ursprünglich von einem realen Rollstuhl gekommen sind und die
Bewegungsmuster einfach aufeinander abgebildet werden können. Um die
Raddaten der zwei Räder auf eine Bewegung und Rotation eines Rollstuhls
umzurechnen, muss erst festgestellt werden, welche Radbewegungen zu
welchen Rollstuhlbewegungen führt. Dabei können drei idealisierte Fälle
unterschieden werden:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Fall: Drehen sich die Räder mit gleicher Geschwindigkeit in dieselbe
  Richtung, so ruft dies eine Bewegung nach vorne oder hinten aus.
\item
  Fall: Drehen sich die Räder mit gleicher Geschwindigkeit
  gegeneinander, so ruft dies eine Rotation um die eigene Achse hervor.
\item
  Fall: Dreht sich nur ein Rad, so dreht sich dieses um das Stehende.
\end{enumerate}

Im Folgenden wird die Berechnung der Bewegungsanteile aufgezeigt,
bestehend aus Bewegung nach vorne/hinten und Rotation um die eigene
Achse: Skizze einfügen \[
\begin{align}
LinkeRadGeschwindigkeit: vL \\
RechteRadGeschwindigkeit: vR \\
RadMinimum: m \\
RadOvershoot: o \\
AbstandDerRäder: d \\
BewegungAufSichtachse: s \\
RotationUmDieEigeneAchse: r \\
\end{align}
\] Da in der Realität die Bewegung nicht idealisiert ist, ist
festzustellen, dass die tatsächliche Bewegung zusammengesetzt ist aus
einer der ersten beiden Fälle und dem dritten Fall: \[
\begin{align}
s = s_{1,2} + s_3 \\
r = r_{1,2} + r_3
\end{align}
\] Um bestimmen zu können, ob es sich um Fall 1 oder Fall 2 handelt,
muss folgende Bedingung geprüft werden, die gilt, wenn sich die Räder
gegeneinander drehen: \[
(vL > 0) \oplus (vR > 0)
\] Die Rotation beider Räder lässt sich in zwei Komponenten aufspalten.
Zum einen den Anteil, den sich beide Räder drehen.
\[m = min(\left| vL \right|-\left| vR\right|)\] Zum anderen der Anteil
den sich ein Rad schneller dreht als das andere.
\[o = \left|\left| vL \right|-\left| vR\right| \right|\] \#\#\#\# Fall 1
Die Bewegung nach vorne (oder hinten) ergibt sich in diesem Fall aus dem
Anteil der Geschwindigkeit, mit denen sich beide Räder drehen.
\[s_1 = m\] \#\#\#\# Fall 2 Um die Rotation um die eigene Achse
errechnen zu können, wird zunächst der Wendekreis \(w_1\) bestimmt.
Dieser Wendekreis ist abhängig vom Abstand der beiden Räder \(d\) und
dessen Mittelpunkt liegt im Mittelpunkt dieses Abstandes. Anschließend
wird mithilfe des RadMinimums \(m\), das Verhältnis von \(m\) zu \(w_1\)
errechnet. Dieses Verhältnis muss zum Schluss mit \(360\) multipliziert
werden, um den resultierenden Winkel \(r_{1,2}\) zu berechnen. \[
\begin{align}
w_1 = d \times π \\
r_{1,2} = (\frac {m} {w_1}) \times 360
\end{align}
\] \#\#\#\# Fall 3 Bei diesem Fall gibt es eine Bewegungs- und eine
Rotationskomponente. Da sich nur ein Rad bewegt, hat sich der Wendekreis
vergrößert zu \(w_2\). Der Durchmesser von \(w_2\) ist nun doppelt so
groß wie von \(w_1\), da das stehende Rad nun der Mittelpunkt des
Wendekreises ist. Jetzt wird der Overshoot \(o\) (also der Anteil der
Bewegung des Rades, das sich mehr als das andere dreht) ins Verhältnis
gesetzt mit \(w_2\) und erhält dadurch \(Θ\). Verrechnet man \(Θ\) mit
dem inneren Wendekreis \(w_1\), so erhält man die Bewegungskomponente
\(s_3\).

\[
\begin{align}
w_2 = 2 \times d \times π \\
Θ = \frac {o} {w_2} \\
s_3 = Θ \times w_1
\end{align}
\] Um die Rotationskomponente \(r_3\) berechnen zu können muss \(Θ\) mit
\(360\) multipliziert werden. \[
\begin{align}
r_3 = Θ \times 360
\end{align}
\] Da die Bewegungskomponenten mit den absoluten Rotationswerten
errechnet wurden, ist es notwendig anhand der Drehrichtungen beider
Räder zu bestimmen, ob sich der Rollstuhl vor- oder zurückbewegt und ob
er sich dabei nach links oder rechts dreht. Die Drehrichtung ist immer
dann links, wenn: \[
vL < vR
\] Es handelt sich um eine Vorwärtsbewegung, wenn: \[
vL + vR > 0
\] \#\#\# Abbildung auf einen idealisierten simulierten Rollstuhl Bei
der Verwendung der Abbildung hin zu einem realistischen Rollstuhl hat
sich gezeigt, dass ein schnelles Vorankommen gestört wird. Ursache dafür
ist, dass die Räder sich in leicht unterschiedlicher Geschwindigkeit
drehen und so automatisch die Bewegung nach vorne Drall nach links oder
rechts bekommt.

Dieses Problem kann gelöst werden, wenn mit den Rotationen beider Räder
ein Mittelwert \(v\) errechnet wird der für die Kalkulation von Fall 1
und Fall 2 statt dem Minimum \(m\) verwendet wird. \[
\begin{align}
v = \frac {(vL + vR)} {2} 
\end{align}
\] Jedoch müssen die Fälle in diesem Fall distinkt sein, da sonst das
Wenden mit einem Rad nicht mehr möglich wäre. Grund dafür ist, dass die
Geschwindigkeiten des stillstehende Rades und das sich Drehenden zu
einem Mittelwert zusammengerechnet werden würde und der Rollstuhl sich
nur nach vorne bewegt, statt sich zu drehen. Das Zusammenrechnen von
Fall 1 oder Fall 2 mit Fall 3 darf also nicht geschehen. Realisiert man
die Bewegung des Rollstuhls indem der Rollstuhl in verschiedenen
Bewegungszuständen sein kann, so kann die Bewegung für jeden Fall
einzeln richtig errechnet werden.

\begin{quote}
Um dieses Problem zu lösen, können die drei verschiedenen Fälle als
distinkt angenommen werden. So ist die Abbildungskalkulation in einem
von drei Zuständen, die die Fälle repräsentieren. Für Fall 1 und Fall 2
kann statt der Verwendung des Minimums \(m\) stattdessen ein
interpolierter Wert \(v\) verwendet werden.
\end{quote}

\hypertarget{abbildung-auf-einen-simulierten-rollstuhl-mit-zusuxe4tzlichen-interaktionen}{%
\subsubsection{Abbildung auf einen simulierten Rollstuhl mit
zusätzlichen
Interaktionen}\label{abbildung-auf-einen-simulierten-rollstuhl-mit-zusuxe4tzlichen-interaktionen}}

Werden wie oben erläutert die Eingaben direkt auf eine Rollstuhlbewegung
abgebildet, so ist der Nutzer eingeschränkt in seinen
Interaktionsmöglichkeiten. Aktionen wie einen Knopfdruck sind in diesen
Fällen nicht möglich. Jedoch können bestimmte Bewegungsmuster, die nicht
zwangsläufig notwendig sind, weggelassen werden, um Interaktionen wie
zum Beispiel das Drücken eines Knopfes abzubilden. Um diese
Bewegungsmuster erkennen zu können, muss die Bewegung der Räder als
diskret verstanden werden. So kann sich ein Rad in drei Zuständen
befinden: Still stehend, nach vorne drehend und nach hinten drehend.
Zwei Räder mit jeweils drei Zuständen ergibt dabei \(3^2 = 9\)
Bewegungsmuster.

{[}{[}WheelchairStates.PNG\textbar500{]}{]} (Abb.3, Bewegungszustände
eines Rollstuhls)

Werden für das Drehen des Rollstuhls nur die Zustände genutzt, bei denen
sich die Räder gegeneinander drehen (in Abb.3 zweite Reihe, erste und
dritte Spalte), so bleiben vier Zustände übrig, die mit anderen
Interaktionen belegt werden können. Bei diesen vier Mustern handelt es
sich, um solche, bei denen ein Rad still steht. Diese können dann
beispielsweise für das Drücken einer der vier Hauptknöpfe des
Spielcontrollers genutzt werden.

Will man weitere Interaktionen abbilden, so ist dies nur noch möglich
über das geziehlte Drehen der Räder in einer bestimmten Geschwindigkeit
durch den Nutzer. Wird beispielsweise der Wertebereich der Raddaten
geteilt, so könnten schnelle Bewegungen anders interpretiert werden als
langsame Bewegungen. In diesem Szenario lässt sich so die Anzahl der
Bewegungsmuster verdoppeln. Ein Ansatz kann es dann sein, bei langsamen
Bewegungen die Rotation nicht auf eine Drehung auf der Stelle zu mappen,
sondern stattdessen auf eine Neigung des Kopfes. Somit wäre der Nutzer
in der Lage, sich frei im Raum umschauen zu können.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{interface-fuxfcr-nutzung-in-spielen-und-software}{%
\subsection{Interface für Nutzung in Spielen und
Software}\label{interface-fuxfcr-nutzung-in-spielen-und-software}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{anwendbarkeit-in-software}{%
\subsection{Anwendbarkeit in Software}\label{anwendbarkeit-in-software}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}
